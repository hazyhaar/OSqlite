/// Synthetic file tree for the Styx namespace.
///
/// This is the "everything is a file" layer. Directories and files are
/// not backed by disk — they're generated on-the-fly from kernel state,
/// SQLite queries, and hardware registers.
use alloc::collections::BTreeMap;
use alloc::string::String;
use alloc::vec::Vec;

/// Unique path ID for Qid generation.
static NEXT_PATH: core::sync::atomic::AtomicU64 = core::sync::atomic::AtomicU64::new(1);

fn alloc_path() -> u64 {
    NEXT_PATH.fetch_add(1, core::sync::atomic::Ordering::Relaxed)
}

/// A node in the synthetic file tree.
pub struct Node {
    pub name: String,
    pub path_id: u64,
    pub kind: NodeKind,
}

/// What kind of node this is.
pub enum NodeKind {
    /// Directory containing child nodes.
    Dir { children: BTreeMap<String, Node> },

    /// Synthetic file — content generated by a callback on read.
    SyntheticFile {
        /// Called on Tread. Returns the file content as bytes.
        on_read: fn() -> Vec<u8>,
        /// Called on Twrite. Receives the written data.
        on_write: Option<fn(&[u8]) -> Result<(), String>>,
    },

    /// Control file — write commands, read responses.
    /// Used for /db/ctl and /hw/gpu/compute/ctl.
    CtlFile {
        /// Process a command written to this file.
        on_command: fn(&[u8]) -> Vec<u8>,
        /// Buffered response from the last command.
        response: Vec<u8>,
    },
}

impl Node {
    /// Create a new directory node.
    pub fn dir(name: &str) -> Self {
        Self {
            name: String::from(name),
            path_id: alloc_path(),
            kind: NodeKind::Dir {
                children: BTreeMap::new(),
            },
        }
    }

    /// Create a new synthetic read-only file.
    pub fn file(name: &str, on_read: fn() -> Vec<u8>) -> Self {
        Self {
            name: String::from(name),
            path_id: alloc_path(),
            kind: NodeKind::SyntheticFile {
                on_read,
                on_write: None,
            },
        }
    }

    /// Create a new read-write synthetic file.
    pub fn file_rw(
        name: &str,
        on_read: fn() -> Vec<u8>,
        on_write: fn(&[u8]) -> Result<(), String>,
    ) -> Self {
        Self {
            name: String::from(name),
            path_id: alloc_path(),
            kind: NodeKind::SyntheticFile {
                on_read,
                on_write: Some(on_write),
            },
        }
    }

    /// Create a control file (write command, read response).
    pub fn ctl(name: &str, on_command: fn(&[u8]) -> Vec<u8>) -> Self {
        Self {
            name: String::from(name),
            path_id: alloc_path(),
            kind: NodeKind::CtlFile {
                on_command,
                response: Vec::new(),
            },
        }
    }

    /// Add a child to a directory node.
    pub fn add_child(&mut self, child: Node) {
        if let NodeKind::Dir { children } = &mut self.kind {
            children.insert(child.name.clone(), child);
        }
    }

    /// Look up a child by name.
    pub fn child(&self, name: &str) -> Option<&Node> {
        if let NodeKind::Dir { children } = &self.kind {
            children.get(name)
        } else {
            None
        }
    }

    /// Look up a child by name (mutable).
    pub fn child_mut(&mut self, name: &str) -> Option<&mut Node> {
        if let NodeKind::Dir { children } = &mut self.kind {
            children.get_mut(name)
        } else {
            None
        }
    }

    /// Is this a directory?
    pub fn is_dir(&self) -> bool {
        matches!(self.kind, NodeKind::Dir { .. })
    }

    /// Read this node's content.
    pub fn read(&self) -> Vec<u8> {
        match &self.kind {
            NodeKind::Dir { children } => {
                // Directory listing: one name per line
                let mut out = Vec::new();
                for name in children.keys() {
                    out.extend_from_slice(name.as_bytes());
                    out.push(b'\n');
                }
                out
            }
            NodeKind::SyntheticFile { on_read, .. } => on_read(),
            NodeKind::CtlFile { response, .. } => response.clone(),
        }
    }

    /// Write data to this node.
    pub fn write(&mut self, data: &[u8]) -> Result<(), String> {
        match &mut self.kind {
            NodeKind::Dir { .. } => Err(String::from("cannot write to directory")),
            NodeKind::SyntheticFile { on_write, .. } => {
                if let Some(handler) = on_write {
                    handler(data)
                } else {
                    Err(String::from("read-only file"))
                }
            }
            NodeKind::CtlFile { on_command, response } => {
                *response = on_command(data);
                Ok(())
            }
        }
    }
}

/// Build the default HeavenOS namespace.
pub fn build_root() -> Node {
    let mut root = Node::dir("");

    // /db/
    let mut db = Node::dir("db");
    db.add_child(Node::ctl("ctl", |_cmd| {
        // TODO: execute SQL via embedded SQLite and return result
        b"ok\n".to_vec()
    }));
    db.add_child(Node::file("schema", || {
        // TODO: query sqlite_master and return schema
        b"-- schema placeholder\n".to_vec()
    }));
    root.add_child(db);

    // /sys/
    let mut sys = Node::dir("sys");
    sys.add_child(Node::file("uptime", || {
        // TODO: real uptime from TSC
        b"0\n".to_vec()
    }));
    sys.add_child(Node::file("meminfo", || {
        use crate::mem::phys::PHYS_ALLOCATOR;
        let free = PHYS_ALLOCATOR.free_count();
        let total = PHYS_ALLOCATOR.total_count();
        let msg = alloc::format!(
            "total_pages: {}\nfree_pages: {}\nused_pages: {}\n",
            total, free, total - free
        );
        msg.into_bytes()
    }));
    root.add_child(sys);

    // /hw/
    let mut hw = Node::dir("hw");
    let nvme = Node::dir("nvme");
    hw.add_child(nvme);
    let gpu = Node::dir("gpu");
    hw.add_child(gpu);
    root.add_child(hw);

    // /agents/
    let agents = Node::dir("agents");
    root.add_child(agents);

    root
}
